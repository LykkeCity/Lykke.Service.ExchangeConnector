// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace TradingBot.Exchanges.Concrete.AutorestClient
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// ## REST API for the BitMEX Trading Platform
    ///
    /// [View Changelog](/app/apiChangelog)
    ///
    /// ----
    ///
    /// #### Getting Started
    ///
    ///
    /// ##### Fetching Data
    ///
    /// All REST endpoints are documented below. You can try out any query
    /// right from this interface.
    ///
    /// Most table queries accept `count`, `start`, and `reverse` params. Set
    /// `reverse=true` to get rows newest-first.
    ///
    /// Additional documentation regarding filters, timestamps, and
    /// authentication
    /// is available in [the main API
    /// documentation](https://www.bitmex.com/app/restAPI).
    ///
    /// *All* table data is available via the [Websocket](/app/wsAPI). We
    /// highly recommend using the socket if you want
    /// to have the quickest possible data without being subject to ratelimits.
    ///
    /// ##### Return Types
    ///
    /// By default, all data is returned as JSON. Send `?_format=csv` to get
    /// CSV data or `?_format=xml` to get XML data.
    ///
    /// ##### Trade Data Queries
    ///
    /// *This is only a small subset of what is available, to get you started.*
    ///
    /// Fill in the parameters and click the `Try it out!` button to try any of
    /// these queries.
    ///
    /// * [Pricing Data](#!/Quote/Quote_get)
    ///
    /// * [Trade Data](#!/Trade/Trade_get)
    ///
    /// * [OrderBook Data](#!/OrderBook/OrderBook_getL2)
    ///
    /// * [Settlement Data](#!/Settlement/Settlement_get)
    ///
    /// * [Exchange Statistics](#!/Stats/Stats_history)
    ///
    /// Every function of the BitMEX.com platform is exposed here and
    /// documented. Many more functions are available.
    ///
    /// ##### Swagger Specification
    ///
    /// [â‡© Download Swagger JSON](swagger.json)
    ///
    /// ----
    ///
    /// ## All API Endpoints
    ///
    /// Click to expand a section.
    ///
    /// </summary>
    public partial interface IBitMEXAPI : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Subscription credentials which uniquely identify client
        /// subscription.
        /// </summary>
        ServiceClientCredentials Credentials { get; }


        /// <summary>
        /// Get site announcements.
        /// </summary>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> AnnouncementgetWithHttpMessagesAsync(string columns = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get urgent (banner) announcements.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> AnnouncementgetUrgentWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new API Key.
        /// </summary>
        /// <remarks>
        /// API Keys can also be created via [this Python
        /// script](https://github.com/BitMEX/market-maker/blob/master/generate-api-key.py)
        /// See the [API Key Documentation](/app/apiKeys) for more information
        /// on capabilities.
        /// </remarks>
        /// <param name='name'>
        /// Key name. This name is for reference only.
        /// </param>
        /// <param name='cidr'>
        /// CIDR block to restrict this key to. To restrict to a single
        /// address, append "/32", e.g. 207.39.29.22/32. Leave blank or set to
        /// 0.0.0.0/0 to allow all IPs. Only one block may be set. &lt;a
        /// href="http://software77.net/cidr-101.html"&gt;More on CIDR
        /// blocks&lt;/a&gt;
        /// </param>
        /// <param name='permissions'>
        /// Key Permissions. All keys can read margin and position data.
        /// Additional permissions must be added. Available: ["order",
        /// "orderCancel", "withdraw"].
        /// </param>
        /// <param name='enabled'>
        /// Set to true to enable this key on creation. Otherwise, it must be
        /// explicitly enabled via /apiKey/enable.
        /// </param>
        /// <param name='token'>
        /// OTP Token (YubiKey, Google Authenticator)
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> APIKeynewWithHttpMessagesAsync(string name = default(string), string cidr = default(string), string permissions = default(string), bool? enabled = false, string token = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your API Keys.
        /// </summary>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> APIKeygetWithHttpMessagesAsync(bool? reverse = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove an API Key.
        /// </summary>
        /// <param name='apiKeyID'>
        /// API Key ID (public component).
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> APIKeyremoveWithHttpMessagesAsync(string apiKeyID, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Disable an API Key.
        /// </summary>
        /// <param name='apiKeyID'>
        /// API Key ID (public component).
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> APIKeydisableWithHttpMessagesAsync(string apiKeyID, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Enable an API Key.
        /// </summary>
        /// <param name='apiKeyID'>
        /// API Key ID (public component).
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> APIKeyenableWithHttpMessagesAsync(string apiKeyID, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get chat messages.
        /// </summary>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting ID for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='channelID'>
        /// Channel id. GET /chat/channels for ids. Leave blank for all.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ChatgetWithHttpMessagesAsync(double? count = 100, double? start = 0, bool? reverse = true, double? channelID = default(double?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Send a chat message.
        /// </summary>
        /// <param name='message'>
        /// </param>
        /// <param name='channelID'>
        /// Channel to post to. Default 1 (English).
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ChatnewWithHttpMessagesAsync(string message, double? channelID = 1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get available channels.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ChatgetChannelsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get connected users.
        /// </summary>
        /// <remarks>
        /// Returns an array with browser users in the first position and API
        /// users (bots) in the second position.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ChatgetConnectedWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all raw executions for your account.
        /// </summary>
        /// <remarks>
        /// This returns all raw transactions, which includes order opening and
        /// cancelation, and order status
        /// changes. It can be quite noisy. More focused information is
        /// available at `/execution/tradeHistory`.
        ///
        /// You may also use the `filter` param to target your query. Specify
        /// an array as a filter value, such as
        /// `{"execType": ["Settlement", "Trade"]}` to filter on multiple
        /// values.
        ///
        /// See [the FIX
        /// Spec](http://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_8_8.html)
        /// for explanations of these fields.
        ///
        /// </remarks>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ExecutiongetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all balance-affecting executions. This includes each trade,
        /// insurance charge, and settlement.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ExecutiongetTradeHistoryWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get funding history.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> FundinggetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get instruments.
        /// </summary>
        /// <remarks>
        /// This returns all instruments and indices, including those that have
        /// settled or are unlisted. Use this endpoint if you want to query for
        /// individual instruments or use a complex filter. Use
        /// `/instrument/active` to return active instruments, or use a filter
        /// like `{"state": "Open"}`.
        /// </remarks>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all active instruments and instruments that have expired in
        /// &lt;24hrs.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetActiveWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all price indices.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetIndicesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Helper method. Gets all active instruments and all indices. This is
        /// a join of the result of /indices and /active.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetActiveAndIndicesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Return all active contract series and interval pairs.
        /// </summary>
        /// <remarks>
        /// This endpoint is useful for determining which pairs are live. It
        /// returns two arrays of   strings. The first is intervals, such as
        /// `["BVOL:daily", "BVOL:weekly", "XBU:daily", "XBU:monthly", ...]`.
        /// These identifiers are usable in any query's `symbol` param. The
        /// second array is the current resolution of these intervals. Results
        /// are mapped at the same index.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetActiveIntervalsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Show constituent parts of an index.
        /// </summary>
        /// <remarks>
        /// Composite indices are built from multiple external price sources.
        ///
        /// Use this endpoint to get the underlying prices of an index. For
        /// example, send a `symbol` of `.XBT` to
        /// get the ticks and weights of the constituent exchanges that build
        /// the ".XBT" index.
        ///
        /// A tick with reference `"BMI"` and weight `null` is the composite
        /// index tick.
        ///
        /// </remarks>
        /// <param name='account'>
        /// </param>
        /// <param name='symbol'>
        /// The composite index symbol.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InstrumentgetCompositeIndexWithHttpMessagesAsync(double? account = default(double?), string symbol = ".XBT", string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get insurance fund history.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> InsurancegetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get current leaderboard.
        /// </summary>
        /// <param name='method'>
        /// Ranking type. Options: "notional", "ROE"
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Leaderboard>>> LeaderboardgetWithHttpMessagesAsync(string method = "notional", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get liquidation orders.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> LiquidationgetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your current notifications.
        /// </summary>
        /// <remarks>
        /// This is an upcoming feature and currently does not return data.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> NotificationgetWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your orders.
        /// </summary>
        /// <remarks>
        /// To get open orders only, send {"open": true} in the filter param.
        ///
        /// See &lt;a
        /// href="http://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_D_68.html"&gt;the
        /// FIX Spec&lt;/a&gt; for explanations of these fields.
        /// </remarks>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdergetOrdersWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new order.
        /// </summary>
        /// <remarks>
        /// ## Placing Orders
        ///
        /// This endpoint is used for placing orders. See individual fields
        /// below for more details on their use.
        ///
        /// #### Order Types
        ///
        /// All orders require a `symbol`. All other fields are optional except
        /// when otherwise specified.
        ///
        /// These are the valid `ordType`s:
        ///
        /// * **Limit**: The default order type. Specify an `orderQty` and
        /// `price`.
        /// * **Market**: A traditional Market order. A Market order will
        /// execute until filled or your bankruptcy price is reached, at
        /// which point it will cancel.
        /// * **MarketWithLeftOverAsLimit**: A market order that, after eating
        /// through the order book as far as
        /// permitted by available margin, will become a limit order. The
        /// difference between this type and `Market` only
        /// affects the behavior in thin books. Upon reaching the deepest
        /// possible price, if there is quantity left over,
        /// a `Market` order will cancel the remaining quantity.
        /// `MarketWithLeftOverAsLimit` will keep the remaining
        /// quantity in the books as a `Limit`.
        /// * **Stop**: A Stop Market order. Specify an `orderQty` and
        /// `stopPx`. When the `stopPx` is reached, the order will be entered
        /// into the book.
        /// * On sell orders, the order will trigger if the triggering price is
        /// lower than the `stopPx`. On buys, higher.
        /// * Note: Stop orders do not consume margin until triggered. Be sure
        /// that the required margin is available in your
        /// account so that it may trigger fully.
        /// * `Close` Stops don't require an `orderQty`. See Execution
        /// Instructions below.
        /// * **StopLimit**: Like a Stop Market, but enters a Limit order
        /// instead of a Market order. Specify an `orderQty`, `stopPx`,
        /// and `price`.
        /// * **MarketIfTouched**: Similar to a Stop, but triggers are done in
        /// the opposite direction. Useful for Take Profit orders.
        /// * **LimitIfTouched**: As above; use for Take Profit Limit orders.
        ///
        /// #### Execution Instructions
        ///
        /// The following `execInst`s are supported. If using multiple,
        /// separate with a comma (e.g. `LastPrice,Close`).
        ///
        /// * **ParticipateDoNotInitiate**: Also known as a Post-Only order. If
        /// this order would have executed on placement,
        /// it will cancel instead.
        /// * **AllOrNone**: Valid only for hidden orders (`displayQty: 0`).
        /// Use to only execute if the entire order would fill.
        /// * **MarkPrice, LastPrice, IndexPrice**: Used by stop and if-touched
        /// orders to determine the triggering price.
        /// Use only one. By default, `'MarkPrice'` is used. Also used for
        /// Pegged orders to define the value of `'LastPeg'`.
        /// * **ReduceOnly**: A `'ReduceOnly'` order can only reduce your
        /// position, not increase it. If you have a `'ReduceOnly'`
        /// limit order that rests in the order book while the position is
        /// reduced by other orders, then its order quantity will
        /// be amended down or canceled. If there are multiple `'ReduceOnly'`
        /// orders the least agresssive will be amended first.
        /// * **Close**: `'Close'` implies `'ReduceOnly'`. A `'Close'` order
        /// will cancel other active limit orders with the same side
        /// and symbol if the open quantity exceeds the current position. This
        /// is useful for stops: by canceling these orders, a
        /// `'Close'` Stop is ensured to have the margin required to execute,
        /// and can only execute up to the full size of your
        /// position. If not specified, a `'Close'` order has an `orderQty`
        /// equal to your current position's size.
        ///
        /// #### Linked Orders
        ///
        /// Linked Orders are an advanced capability. It is very powerful, but
        /// its use requires careful coding and testing.
        /// Please follow this document carefully and use the [Testnet
        /// Exchange](https://testnet.bitmex.com) while developing.
        ///
        /// BitMEX offers four advanced Linked Order types:
        ///
        /// * **OCO**: *One Cancels the Other*. A very flexible version of the
        /// standard Stop / Take Profit technique.
        /// Multiple orders may be linked together using a single
        /// `clOrdLinkID`. Send a `contingencyType` of
        /// `OneCancelsTheOther` on the orders. The first order that fully or
        /// partially executes (or activates
        /// for `Stop` orders) will cancel all other orders with the same
        /// `clOrdLinkID`.
        /// * **OTO**: *One Triggers the Other*. Send a `contingencyType` of
        /// `'OneTriggersTheOther'` on the primary order and
        /// then subsequent orders with the same `clOrdLinkID` will be not be
        /// triggered until the primary order fully executes.
        /// * **OUOA**: *One Updates the Other Absolute*. Send a
        /// `contingencyType` of `'OneUpdatesTheOtherAbsolute'` on the orders.
        /// Then
        /// as one order has a execution, other orders with the same
        /// `clOrdLinkID` will have their order quantity amended
        /// down by the execution quantity.
        /// * **OUOP**: *One Updates the Other Proportional*. Send a
        /// `contingencyType` of `'OneUpdatesTheOtherProportional'` on the
        /// orders. Then
        /// as one order has a execution, other orders with the same
        /// `clOrdLinkID` will have their order quantity reduced proportionally
        /// by the fill percentage.
        ///
        /// #### Trailing Stops
        ///
        /// You may use `pegPriceType` of `'TrailingStopPeg'` to create
        /// Trailing Stops. The pegged `stopPx` will move as the market
        /// moves away from the peg, and freeze as the market moves toward it.
        ///
        /// To use, combine with `pegOffsetValue` to set the `stopPx` of your
        /// order. The peg is set to the triggering price
        /// specified in the `execInst` (default `'MarkPrice'`). Use a negative
        /// offset for stop-sell and buy-if-touched orders.
        ///
        /// Requires `ordType`: `'Stop', 'StopLimit', 'MarketIfTouched',
        /// 'LimitIfTouched'`.
        ///
        /// #### Simple Quantities
        ///
        /// Send a `simpleOrderQty` instead of an `orderQty` to create an order
        /// denominated in the underlying currency.
        /// This is useful for opening up a position with 1 XBT of exposure
        /// without having to calculate how many contracts it is.
        ///
        /// #### Rate Limits
        ///
        /// See the [Bulk Order Documentation](#!/Order/Order_newBulk) if you
        /// need to place multiple orders at the same time.
        /// Bulk orders require fewer risk checks in the trading engine and
        /// thus are ratelimited at **1/10** the normal rate.
        ///
        /// You can also improve your reactivity to market movements while
        /// staying under your ratelimit by using the
        /// [Amend](#!/Order/Order_amend) and [Amend
        /// Bulk](#!/Order/Order_amendBulk) endpoints. This allows you to stay
        /// in the market and avoids the cancel/replace cycle.
        ///
        /// #### Tracking Your Orders
        ///
        /// If you want to keep track of order IDs yourself, set a unique
        /// `clOrdID` per order.
        /// This `clOrdID` will come back as a property on the order and any
        /// related executions (including on the WebSocket),
        /// and can be used to get or cancel the order. Max length is 36
        /// characters.
        ///
        /// </remarks>
        /// <param name='symbol'>
        /// Instrument symbol. e.g. 'XBTUSD'.
        /// </param>
        /// <param name='side'>
        /// Order side. Valid options: Buy, Sell. Defaults to 'Buy' unless
        /// `orderQty` or `simpleOrderQty` is negative.
        /// </param>
        /// <param name='simpleOrderQty'>
        /// Order quantity in units of the underlying instrument (i.e.
        /// Bitcoin).
        /// </param>
        /// <param name='quantity'>
        /// Deprecated: use `orderQty`.
        /// </param>
        /// <param name='orderQty'>
        /// Order quantity in units of the instrument (i.e. contracts).
        /// </param>
        /// <param name='price'>
        /// Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched'
        /// orders.
        /// </param>
        /// <param name='displayQty'>
        /// Optional quantity to display in the book. Use 0 for a fully hidden
        /// order.
        /// </param>
        /// <param name='stopPrice'>
        /// Deprecated: use `stopPx`.
        /// </param>
        /// <param name='stopPx'>
        /// Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched',
        /// and 'LimitIfTouched' orders. Use a price below the current price
        /// for stop-sell orders and buy-if-touched orders. Use `execInst` of
        /// 'MarkPrice' or 'LastPrice' to define the current price used for
        /// triggering.
        /// </param>
        /// <param name='clOrdID'>
        /// Optional Client Order ID. This clOrdID will come back on the order
        /// and any related executions.
        /// </param>
        /// <param name='clOrdLinkID'>
        /// Optional Client Order Link ID for contingent orders.
        /// </param>
        /// <param name='pegOffsetValue'>
        /// Optional trailing offset from the current price for 'Stop',
        /// 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a
        /// negative offset for stop-sell orders and buy-if-touched orders.
        /// Optional offset from the peg price for 'Pegged' orders.
        /// </param>
        /// <param name='pegPriceType'>
        /// Optional peg price type. Valid options: LastPeg, MidPricePeg,
        /// MarketPeg, PrimaryPeg, TrailingStopPeg.
        /// </param>
        /// <param name='type'>
        /// Deprecated: use `ordType`.
        /// </param>
        /// <param name='ordType'>
        /// Order type. Valid options: Market, Limit, Stop, StopLimit,
        /// MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged.
        /// Defaults to 'Limit' when `price` is specified. Defaults to 'Stop'
        /// when `stopPx` is specified. Defaults to 'StopLimit' when `price`
        /// and `stopPx` are specified.
        /// </param>
        /// <param name='timeInForce'>
        /// Time in force. Valid options: Day, GoodTillCancel,
        /// ImmediateOrCancel, FillOrKill. Defaults to 'GoodTillCancel' for
        /// 'Limit', 'StopLimit', 'LimitIfTouched', and
        /// 'MarketWithLeftOverAsLimit' orders.
        /// </param>
        /// <param name='execInst'>
        /// Optional execution instructions. Valid options:
        /// ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice,
        /// LastPrice, Close, ReduceOnly, Fixed. 'AllOrNone' instruction
        /// requires `displayQty` to be 0. 'MarkPrice', 'IndexPrice' or
        /// 'LastPrice' instruction valid for 'Stop', 'StopLimit',
        /// 'MarketIfTouched', and 'LimitIfTouched' orders.
        /// </param>
        /// <param name='contingencyType'>
        /// Optional contingency type for use with `clOrdLinkID`. Valid
        /// options: OneCancelsTheOther, OneTriggersTheOther,
        /// OneUpdatesTheOtherAbsolute, OneUpdatesTheOtherProportional.
        /// </param>
        /// <param name='text'>
        /// Optional order annotation. e.g. 'Take profit'.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdernewWithHttpMessagesAsync(string symbol, string side = default(string), double? simpleOrderQty = default(double?), double? quantity = default(double?), double? orderQty = default(double?), double? price = default(double?), double? displayQty = default(double?), double? stopPrice = default(double?), double? stopPx = default(double?), string clOrdID = default(string), string clOrdLinkID = default(string), double? pegOffsetValue = default(double?), string pegPriceType = default(string), string type = default(string), string ordType = "Limit", string timeInForce = default(string), string execInst = default(string), string contingencyType = default(string), string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Amend the quantity or price of an open order.
        /// </summary>
        /// <remarks>
        /// Send an `orderID` or `origClOrdID` to identify the order you wish
        /// to amend.
        ///
        /// Both order quantity and price can be amended. Only one `qty` field
        /// can be used to amend.
        ///
        /// Use the `leavesQty` field to specify how much of the order you wish
        /// to remain open. This can be useful
        /// if you want to adjust your position's delta by a certain amount,
        /// regardless of how much of the order has
        /// already filled.
        ///
        /// Use the `simpleOrderQty` and `simpleLeavesQty` fields to specify
        /// order size in Bitcoin, rather than contracts.
        /// These fields will round up to the nearest contract.
        ///
        /// Like order placement, amending can be done in bulk. Simply send a
        /// request to `PUT /api/v1/order/bulk` with
        /// a JSON body of the shape: `{"orders": [{...}, {...}]}`, each object
        /// containing the fields used in this endpoint.
        ///
        /// </remarks>
        /// <param name='orderID'>
        /// Order ID
        /// </param>
        /// <param name='origClOrdID'>
        /// Client Order ID. See POST /order.
        /// </param>
        /// <param name='clOrdID'>
        /// Optional new Client Order ID, requires `origClOrdID`.
        /// </param>
        /// <param name='simpleOrderQty'>
        /// Optional order quantity in units of the underlying instrument (i.e.
        /// Bitcoin).
        /// </param>
        /// <param name='orderQty'>
        /// Optional order quantity in units of the instrument (i.e.
        /// contracts).
        /// </param>
        /// <param name='simpleLeavesQty'>
        /// Optional leaves quantity in units of the underlying instrument
        /// (i.e. Bitcoin). Useful for amending partially filled orders.
        /// </param>
        /// <param name='leavesQty'>
        /// Optional leaves quantity in units of the instrument (i.e.
        /// contracts). Useful for amending partially filled orders.
        /// </param>
        /// <param name='price'>
        /// Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched'
        /// orders.
        /// </param>
        /// <param name='stopPx'>
        /// Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched',
        /// and 'LimitIfTouched' orders. Use a price below the current price
        /// for stop-sell orders and buy-if-touched orders.
        /// </param>
        /// <param name='pegOffsetValue'>
        /// Optional trailing offset from the current price for 'Stop',
        /// 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a
        /// negative offset for stop-sell orders and buy-if-touched orders.
        /// Optional offset from the peg price for 'Pegged' orders.
        /// </param>
        /// <param name='text'>
        /// Optional amend annotation. e.g. 'Adjust skew'.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrderamendWithHttpMessagesAsync(string orderID = default(string), string origClOrdID = default(string), string clOrdID = default(string), double? simpleOrderQty = default(double?), double? orderQty = default(double?), double? simpleLeavesQty = default(double?), double? leavesQty = default(double?), double? price = default(double?), double? stopPx = default(double?), double? pegOffsetValue = default(double?), string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Cancel order(s). Send multiple order IDs to cancel in bulk.
        /// </summary>
        /// <remarks>
        /// Either an orderID or a clOrdID must be provided.
        /// </remarks>
        /// <param name='orderID'>
        /// Order ID(s).
        /// </param>
        /// <param name='clOrdID'>
        /// Client Order ID(s). See POST /order.
        /// </param>
        /// <param name='text'>
        /// Optional cancellation annotation. e.g. 'Spread Exceeded'.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdercancelWithHttpMessagesAsync(string orderID = default(string), string clOrdID = default(string), string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create multiple new orders for the same symbol.
        /// </summary>
        /// <remarks>
        /// This endpoint is used for placing bulk orders. Valid order types
        /// are Market, Limit, Stop, StopLimit, MarketIfTouched,
        /// LimitIfTouched, MarketWithLeftOverAsLimit, and Pegged.
        ///
        /// Each individual order object in the array should have the same
        /// properties as an individual POST /order call.
        ///
        /// This endpoint is much faster for getting many orders into the book
        /// at once. Because it reduces load on BitMEX
        /// systems, this endpoint is ratelimited at `ceil(0.1 * orders)`.
        /// Submitting 10 orders via a bulk order call
        /// will only count as 1 request, 15 as 2, 32 as 4, and so on.
        ///
        /// For now, only `application/json` is supported on this endpoint.
        ///
        /// </remarks>
        /// <param name='orders'>
        /// An array of orders.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdernewBulkWithHttpMessagesAsync(string orders = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Amend multiple orders for the same symbol.
        /// </summary>
        /// <remarks>
        /// Similar to POST /amend, but with multiple orders.
        /// `application/json` only. Ratelimited at 50%.
        /// </remarks>
        /// <param name='orders'>
        /// An array of orders.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrderamendBulkWithHttpMessagesAsync(string orders = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Close a position. [Deprecated, use POST /order with execInst:
        /// 'Close']
        /// </summary>
        /// <remarks>
        /// If no `price` is specified, a market order will be submitted to
        /// close the whole of your position. This will also close all other
        /// open orders in this symbol.
        /// </remarks>
        /// <param name='symbol'>
        /// Symbol of position to close.
        /// </param>
        /// <param name='price'>
        /// Optional limit price.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrderclosePositionWithHttpMessagesAsync(string symbol, double? price = default(double?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Cancels all of your orders.
        /// </summary>
        /// <param name='symbol'>
        /// Optional symbol. If provided, only cancels orders for that symbol.
        /// </param>
        /// <param name='filter'>
        /// Optional filter for cancellation. Use to only cancel some orders,
        /// e.g. `{"side": "Buy"}`.
        /// </param>
        /// <param name='text'>
        /// Optional cancellation annotation. e.g. 'Spread Exceeded'
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdercancelAllWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Automatically cancel all your orders after a specified timeout.
        /// </summary>
        /// <remarks>
        /// Useful as a dead-man's switch to ensure your orders are canceled in
        /// case of an outage.
        /// If called repeatedly, the existing offset will be canceled and a
        /// new one will be inserted in its place.
        ///
        /// Example usage: call this route at 15s intervals with an offset of
        /// 60000 (60s).
        /// If this route is not called within 60 seconds, all your orders will
        /// be automatically canceled.
        ///
        /// This is also available via
        /// [WebSocket](https://www.bitmex.com/app/wsAPI#Dead-Mans-Switch-Auto-Cancel).
        ///
        /// </remarks>
        /// <param name='timeout'>
        /// Timeout in ms. Set to 0 to cancel this timer.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrdercancelAllAfterWithHttpMessagesAsync(double timeout, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get current orderbook [deprecated, use /orderBook/L2].
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a series (e.g. XBT) to get data for the
        /// nearest contract in that series.
        /// </param>
        /// <param name='depth'>
        /// Orderbook depth.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrderBookgetWithHttpMessagesAsync(string symbol, double? depth = 25, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get current orderbook in vertical format.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a series (e.g. XBT) to get data for the
        /// nearest contract in that series.
        /// </param>
        /// <param name='depth'>
        /// Orderbook depth per side. Send 0 for full depth.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> OrderBookgetL2WithHttpMessagesAsync(string symbol, double? depth = 25, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your positions.
        /// </summary>
        /// <remarks>
        /// See &lt;a
        /// href="http://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_AP_6580.html"&gt;the
        /// FIX Spec&lt;/a&gt; for explanations of these fields.
        /// </remarks>
        /// <param name='filter'>
        /// Table filter. For example, send {"symbol": "XBTUSD"}.
        /// </param>
        /// <param name='columns'>
        /// Which columns to fetch. For example, send ["columnName"].
        /// </param>
        /// <param name='count'>
        /// Number of rows to fetch.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> PositiongetWithHttpMessagesAsync(string filter = default(string), string columns = default(string), double? count = default(double?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Enable isolated margin or cross margin per-position.
        /// </summary>
        /// <remarks>
        /// Users can switch isolate margin per-position. This function allows
        /// switching margin isolation (aka fixed margin) on and off.
        /// </remarks>
        /// <param name='symbol'>
        /// Position symbol to isolate.
        /// </param>
        /// <param name='enabled'>
        /// True for isolated margin, false for cross margin.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> PositionisolateMarginWithHttpMessagesAsync(string symbol, bool? enabled = true, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update your risk limit.
        /// </summary>
        /// <remarks>
        /// Risk Limits limit the size of positions you can trade at various
        /// margin levels. Larger positions require more margin. Please see the
        /// Risk Limit documentation for more details.
        /// </remarks>
        /// <param name='symbol'>
        /// Symbol of position to isolate.
        /// </param>
        /// <param name='riskLimit'>
        /// New Risk Limit, in Satoshis.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> PositionupdateRiskLimitWithHttpMessagesAsync(string symbol, double riskLimit, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Transfer equity in or out of a position.
        /// </summary>
        /// <remarks>
        /// When margin is isolated on a position, use this function to add or
        /// remove margin from the position. Note that you cannot remove margin
        /// below the initial margin threshold.
        /// </remarks>
        /// <param name='symbol'>
        /// Symbol of position to isolate.
        /// </param>
        /// <param name='amount'>
        /// Amount to transfer, in Satoshis. May be negative.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> PositiontransferIsolatedMarginWithHttpMessagesAsync(string symbol, double amount, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Choose leverage for a position.
        /// </summary>
        /// <remarks>
        /// Users can choose an isolated leverage. This will automatically
        /// enable isolated margin.
        /// </remarks>
        /// <param name='symbol'>
        /// Symbol of position to adjust.
        /// </param>
        /// <param name='leverage'>
        /// Leverage value. Send a number between 0.01 and 100 to enable
        /// isolated margin with a fixed leverage. Send 0 to enable cross
        /// margin.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> PositionupdateLeverageWithHttpMessagesAsync(string symbol, double leverage, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get Quotes.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> QuotegetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get previous quotes in time buckets.
        /// </summary>
        /// <param name='binSize'>
        /// Time interval to bucket by. Available options: [1m,5m,1h,1d].
        /// </param>
        /// <param name='partial'>
        /// If true, will send in-progress (incomplete) bins for the current
        /// time period.
        /// </param>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> QuotegetBucketedWithHttpMessagesAsync(string binSize = "1m", bool? partial = false, string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get model schemata for data objects returned by this API.
        /// </summary>
        /// <param name='model'>
        /// Optional model filter. If omitted, will return all models.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> SchemagetWithHttpMessagesAsync(string model = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns help text &amp; subject list for websocket usage.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> SchemawebsocketHelpWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get settlement history.
        /// </summary>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> SettlementgetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get exchange-wide and per-series turnover and volume statistics.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> StatsgetWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get historical exchange-wide and per-series turnover and volume
        /// statistics.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> StatshistoryWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a summary of exchange statistics in USD.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> StatshistoryUSDWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get Trades.
        /// </summary>
        /// <remarks>
        /// Please note that indices (symbols starting with `.`) post trades at
        /// intervals to the trade feed. These have a `size` of 0 and are used
        /// only to indicate a changing price.
        ///
        /// See [the FIX
        /// Spec](http://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_AE_6569.html)
        /// for explanations of these fields.
        /// </remarks>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> TradegetWithHttpMessagesAsync(string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get previous trades in time buckets.
        /// </summary>
        /// <param name='binSize'>
        /// Time interval to bucket by. Available options: [1m,5m,1h,1d].
        /// </param>
        /// <param name='partial'>
        /// If true, will send in-progress (incomplete) bins for the current
        /// time period.
        /// </param>
        /// <param name='symbol'>
        /// Instrument symbol. Send a bare series (e.g. XBU) to get data for
        /// the nearest expiring contract in that series.
        ///
        /// You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are
        /// `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
        /// </param>
        /// <param name='filter'>
        /// Generic table filter. Send JSON key/value pairs, such as `{"key":
        /// "value"}`. You can key on individual fields, and do more advanced
        /// querying on timestamps. See the [Timestamp
        /// Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for
        /// more details.
        /// </param>
        /// <param name='columns'>
        /// Array of column names to fetch. If omitted, will return all
        /// columns.
        ///
        /// Note that this method will always return item keys, even when not
        /// specified, so you may receive more columns that you expect.
        /// </param>
        /// <param name='count'>
        /// Number of results to fetch.
        /// </param>
        /// <param name='start'>
        /// Starting point for results.
        /// </param>
        /// <param name='reverse'>
        /// If true, will sort results newest first.
        /// </param>
        /// <param name='startTime'>
        /// Starting date filter for results.
        /// </param>
        /// <param name='endTime'>
        /// Ending date filter for results.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> TradegetBucketedWithHttpMessagesAsync(string binSize = "1m", bool? partial = false, string symbol = default(string), string filter = default(string), string columns = default(string), double? count = 100, double? start = 0, bool? reverse = false, System.DateTime? startTime = default(System.DateTime?), System.DateTime? endTime = default(System.DateTime?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a deposit address.
        /// </summary>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> UsergetDepositAddressWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your current wallet information.
        /// </summary>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Wallet>> UsergetWalletWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a history of all of your wallet transactions (deposits,
        /// withdrawals, PNL).
        /// </summary>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Transaction>>> UsergetWalletHistoryWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a summary of all of your wallet transactions (deposits,
        /// withdrawals, PNL).
        /// </summary>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Transaction>>> UsergetWalletSummaryWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get the minimum withdrawal fee for a currency.
        /// </summary>
        /// <remarks>
        /// This is changed based on network conditions to ensure timely
        /// withdrawals. During network congestion, this may be high. The fee
        /// is returned in the same currency.
        /// </remarks>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> UserminWithdrawalFeeWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request a withdrawal to an external wallet.
        /// </summary>
        /// <remarks>
        /// This will send a confirmation email to the email address on record,
        /// unless requested via an API Key with the `withdraw` permission.
        /// </remarks>
        /// <param name='currency'>
        /// Currency you're withdrawing. Options: `XBt`
        /// </param>
        /// <param name='amount'>
        /// Amount of withdrawal currency.
        /// </param>
        /// <param name='address'>
        /// Destination Address.
        /// </param>
        /// <param name='otpToken'>
        /// 2FA token. Required if 2FA is enabled on your account.
        /// </param>
        /// <param name='fee'>
        /// Network fee for Bitcoin withdrawals. If not specified, a default
        /// value will be calculated based on Bitcoin network conditions. You
        /// will have a chance to confirm this via email.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Transaction>> UserrequestWithdrawalWithHttpMessagesAsync(string currency, double amount, string address, string otpToken = default(string), double? fee = default(double?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Cancel a withdrawal.
        /// </summary>
        /// <param name='token'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Transaction>> UsercancelWithdrawalWithHttpMessagesAsync(string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Confirm a withdrawal.
        /// </summary>
        /// <param name='token'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Transaction>> UserconfirmWithdrawalWithHttpMessagesAsync(string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get secret key for setting up two-factor auth.
        /// </summary>
        /// <remarks>
        /// Use /confirmEnableTFA directly for Yubikeys. This fails if TFA is
        /// already enabled.
        /// </remarks>
        /// <param name='type'>
        /// Two-factor auth type. Supported types: 'GA' (Google Authenticator)
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<bool?>> UserrequestEnableTFAWithHttpMessagesAsync(string type = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Confirm two-factor auth for this account. If using a Yubikey,
        /// simply send a token to this endpoint.
        /// </summary>
        /// <param name='token'>
        /// Token from your selected TFA type.
        /// </param>
        /// <param name='type'>
        /// Two-factor auth type. Supported types: 'GA' (Google Authenticator),
        /// 'Yubikey'
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<bool?>> UserconfirmEnableTFAWithHttpMessagesAsync(string token, string type = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Disable two-factor auth for this account.
        /// </summary>
        /// <param name='token'>
        /// Token from your selected TFA type.
        /// </param>
        /// <param name='type'>
        /// Two-factor auth type. Supported types: 'GA' (Google Authenticator)
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<bool?>> UserdisableTFAWithHttpMessagesAsync(string token, string type = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Confirm your email address with a token.
        /// </summary>
        /// <param name='token'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AccessToken>> UserconfirmWithHttpMessagesAsync(string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your current affiliate/referral status.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Affiliate>> UsergetAffiliateStatusWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Check if a referral code is valid.
        /// </summary>
        /// <remarks>
        /// If the code is valid, responds with the referral code's discount
        /// (e.g. `0.1` for 10%). Otherwise, will return a 404.
        /// </remarks>
        /// <param name='referralCode'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<double?>> UsercheckReferralCodeWithHttpMessagesAsync(string referralCode = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log out of BitMEX.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> UserlogoutWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log all systems out of BitMEX. This will revoke all of your
        /// account's access tokens, logging you out on all devices.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<double?>> UserlogoutAllWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Save user preferences.
        /// </summary>
        /// <param name='prefs'>
        /// </param>
        /// <param name='overwrite'>
        /// If true, will overwrite all existing preferences.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<User>> UsersavePreferencesWithHttpMessagesAsync(string prefs, bool? overwrite = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your user model.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<User>> UsergetWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update your password, name, and other attributes.
        /// </summary>
        /// <param name='firstname'>
        /// </param>
        /// <param name='lastname'>
        /// </param>
        /// <param name='oldPassword'>
        /// </param>
        /// <param name='newPassword'>
        /// </param>
        /// <param name='newPasswordConfirm'>
        /// </param>
        /// <param name='username'>
        /// Username can only be set once. To reset, email support.
        /// </param>
        /// <param name='country'>
        /// Country of residence.
        /// </param>
        /// <param name='pgpPubKey'>
        /// PGP Public Key. If specified, automated emails will be sentwith
        /// this key.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<User>> UserupdateWithHttpMessagesAsync(string firstname = default(string), string lastname = default(string), string oldPassword = default(string), string newPassword = default(string), string newPasswordConfirm = default(string), string username = default(string), string country = default(string), string pgpPubKey = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your account's commission status.
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<UserCommission>>> UsergetCommissionWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get your account's margin status. Send a currency of "all" to
        /// receive an array of all supported currencies.
        /// </summary>
        /// <param name='currency'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Margin>> UsergetMarginWithHttpMessagesAsync(string currency = "XBt", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
